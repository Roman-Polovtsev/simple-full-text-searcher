BeanDefinitonReader парсит описание и создает beanDefiniton
они кладутся в мапу: айди Бина против его декларации
бинфактори читает это и создает Бины(там только синглтоны, прототайпы идут на лету)

по пути есть BPP с двумя методами - один работает до init метода, другой - после
BPP нужно регистрировать как бин

delayQueue

Wire mock
Pri

Постконстракт нужен для двухфазного конструктора - спринг сначала вызывает конструктор, но поля могут быть еще не заинжекчены спринтом - а после отработки autowiredBpp в них появятся значения, которые можно вызывать в postconstruct, а в основном конструкторе они были бы null
PostConstruct всегда работает на оригинальном объекте, а в postProcessAfterInti. может создавать прокси вокруг нашего объекта, предварительно складывая наши объекты в мапу по имени бина к самому классу

APllicationListner (разные типа эвентов из которых можно таскать контекст )
Пример использования- нужно предварительно во время поднятия контекста сходилть в базу через транзакции
Во время выполенния конструктора еще ничего нет, во время postConstruct еще не отработал TransactionBPP , поэтому нужно когда-то позже
Нужно реализовать интерфейс ApplicationLitener<COntextEvent>

beanFactoryPostProcessor позволяет настраивать бин дефинишны еще до создания Бинов - например так подставляются значения из аннотации @Value

Есть ClassPathBeanDefinitionScanner который ищет все классы с аннотацией @component и делает их них биндефинишены
Аналогично создаются дефинишны из java кончика
@Import импортирует другую джава конфигурацию

КОгда у нас есть javaConfig то вокруг накручиавется прокси и каждый раз когда нам нужен бин - обращаются к классу

ApplicationContextInitializer - добавляет бин дефинишны в контекст спринга = beanDefinitonDsl, работает когда контекст создан, но в нем ничего кроме энвайронмента нету

 Чтобы внедрить прототайп в синглтон можно:
использовать proxyMode = target_class
можно сделать класс абстрактным и метод где идет обращение к прототипу таким же - далее в джава конфиге создать бин синглтона и реализовать абстрактный метод делегированием к методу создания Бина-прототайпа из этого же кончика ﻿ ﻿

ЧТобы добавить свой блок dependency-mangemnt можно импортировать в мавен bom
В буте создается annotationCOnfigAppContext
В стартере создается spring.factories ( в нем:
Прописываем EnableAutoConfiguration = класс с конфиграцией бинов нашего стартера
Также можно прописать свой кастомный ApplicationContextInitializer
)

@SpringBootApp. содержит @EnableAutoConfiguration, @ComponentScan,@Configuration
В @EnableAutoConfiguration содержится ImportSelector -  класс который читает все спринг факторис
МОжно писать свою аннотацию, к ней прикрепить @Condtional(тут конкртеный класс с нашей логикой реализующей интерфес Condition)
Через @ConfigurationProperties можно создать свои проперти для яла
в java конфигурации по имени метода будет имя бина, причем бины из разных конфигов могут друг друга перетирать если у них одинакоое имя



Java


DDD
BoundedContext - разделение одного термина на разные контексты его использования(например Пользователь с точки зрения авторизации/подписки/бизнес-функционала) - потенциальный кандидат на выделение в отдельный микросервис (1 контекст = 1 микросервис, в рамках контекста все термины имеют одно значение)
Сущность(энтити) - экземпляр важного объекта имеющий уникальный id, который не меняется в цикле жизни приложения, могут быть связаны друг с другом через id (например, пользователь/таска/коммент, но например «проект» не будет таким считаться, так как энтити не могут быть вложенными)
Аггрегат - кластер сущностей которые объединены общем корнем(например, проект), изменения в рамках агрегата должны быть транзакционны (например при изменении комментариев к вопросу, счетчик комментраиев у вопроса должен быть обновлен атомарной вместе с комментарием) либо же для nosql  запись аггрегата могут храниться вложенные энтити. Аггрегаты выделяем с точки зрения согласованности в глазах бизнеса (то есть изменение вложенной энтити должно быть консистентным обновлением всего агрегата  - если добавили комментарий к задаче, то задача обновляется атомарно с ним)
В идеал




